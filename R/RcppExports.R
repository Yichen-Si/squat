# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

cpp_pbbinom_one <- function(x, size, alpha, beta, lower_tail, log_prob) {
    .Call(`_squat_cpp_pbbinom_one`, x, size, alpha, beta, lower_tail, log_prob)
}

cpp_dbbinom_one <- function(x, size, alpha, beta, log_prob) {
    .Call(`_squat_cpp_dbbinom_one`, x, size, alpha, beta, log_prob)
}

cpp_dbbinom <- function(x, size, alpha, beta, log_prob) {
    .Call(`_squat_cpp_dbbinom`, x, size, alpha, beta, log_prob)
}

cpp_pbbinom <- function(x, size, alpha, beta, lower_tail, log_prob) {
    .Call(`_squat_cpp_pbbinom`, x, size, alpha, beta, lower_tail, log_prob)
}

cpp_rbbinom <- function(n, size, alpha, beta) {
    .Call(`_squat_cpp_rbbinom`, n, size, alpha, beta)
}

#' Internal function to calculate \phi(\Phi^{-1}(F(x)))
#'
#' @param x observed count
#' @param n total number of trials
#' @param p 0-1 range binomial probability
#' @param lg compute log-scale
#' @return \phi(\Phi^{-1}(F(x))) where F(x) = pbinom(x,n,p)
NULL

#' Internal function to calculate \phi(\Phi^{-1}(2*F(x))) or \phi(\Phi^{-1}(2(F(x)-F(0))/(1-F(0))))
#'
#' @param x observed count (smaller than median)
#' @param n total number of trials
#' @param p 0-1 range binomial probability
#' @param lg compute log-scale
#' @param pos_only consider positive values only
#' @param f0 Pr(X=0) or log Pr(X=0)
#' @return \phi(\Phi^{-1}(2*F(x))) (pos_only=false) or \phi(\Phi^{-1}(2(F(x)-F(0))/(1-F(0)))) (pos_only=true)
NULL

#' Internal function to calculate \phi(\Phi^{-1}(2*F_c(x))) or \phi(\Phi^{-1}(2(F_c(x))/(1-F(0))))
#'
#' @param x observed count (greater than median)
#' @param n total number of trials
#' @param p 0-1 range binomial probability
#' @param lg compute log-scale
#' @param pos_only consider positive values only
#' @param f0 Pr(X=0) or log Pr(X=0)
#' @return \phi(\Phi^{-1}(2*F_c(x))) (pos_only=false) or \phi(\Phi^{-1}(2(F_c(x))/(1-F(0)))) (pos_only=true)
NULL

#' Internal function to calculate \phi(\Phi^{-1}(q)
#'
#' @param q quantile value
#' @param lt quantile is lower tail
#' @param lg log-scale computation
#' @return \phi(\Phi^{-1}(q)
NULL

#' Internal Function to calculate unidirectional z-score for single binomial distribution
#' 
#' @param x            observed count
#' @param n            total number of trials
#' @param p            0-1 ranged binomial probability
#' @param var_adj      perform variance adjustment if TRUE
#' @param approx_under threshold of binomial density to perform approximation during variance adjustment
#' @return A pair of (z-score,stdev) corresponding to the input parameters
NULL

#' Internal Function to calculate bidirectional z-score for single binomial distribution
#' 
#' @param x            observed count
#' @param n            total number of trials
#' @param p            0-1 ranged binomial probability
#' @param pos_only     ignore zeros if TRUE (x must be positive)
#' @param var_adj      perform variance adjustment if TRUE
#' @param approx_under threshold of binomial density to perform approximation during variance adjustment
#' @return A pair of (z-score,stdev) corresponding to the input parameters
NULL

#' Function to calculate unidirectional z-score for single binomial distribution
#' 
#' @param x            observed count
#' @param n            total number of trials
#' @param p            0-1 ranged binomial probability
#' @param var_adj      perform variance adjustment if TRUE
#' @param approx_under threshold of binomial density to perform approximation during variance adjustment
#' @return A named NumericVector containing z-score (z) and stdard deviation (sd)
squat_single_binom_unidir <- function(x, n, p, var_adj = TRUE, approx_under = 1e-4) {
    .Call(`_squat_squat_single_binom_unidir`, x, n, p, var_adj, approx_under)
}

#' Internal Function to calculate bidirectional z-score for single binomial distribution
#' 
#' @param x            observed count
#' @param n            total number of trials
#' @param p            0-1 ranged binomial probability
#' @param pos_only     ignore zeros if TRUE (x must be positive)
#' @param var_adj      perform variance adjustment if TRUE
#' @param approx_under threshold of binomial density to perform approximation during variance adjustment
#' @return A named NumericVector containing z-score (z) and stdard deviation (sd)
squat_single_binom_bidir <- function(x, n, p, pos_only = TRUE, var_adj = TRUE, approx_under = 1e-4) {
    .Call(`_squat_squat_single_binom_bidir`, x, n, p, pos_only, var_adj, approx_under)
}

#' A function to generate unidirectional z scores based on exact quantiles from binomial distribution
#' 
#' @param xs A integer vector containing the list of observed counts. 
#' @param sizes A integer vector containg the list of total counts. Must be the same length with xs or a constant
#' @param ps A numeric vector containing the binomial probability for each observations. Must be the same length with ps or a constant
#' @param var_adj Apply variance adjustment to improve power
#' @param approx_under Perform approximation in variance adjustment for Pr(X=x) smaller than the value
#' @return A DataFrame containing the following attributes
#'    * zs : vector of z-scores corresponding to expected aggregated z-scores from SQuAT
#'    * sds : standard deviation of the expected z-scores (should be smaller than 1)
squat_multi_binom_unidir <- function(xs, sizes, ps, var_adj = TRUE, approx_under = 1e-4) {
    .Call(`_squat_squat_multi_binom_unidir`, xs, sizes, ps, var_adj, approx_under)
}

#' A function to generate bidirectional z scores based on exact quantiles from binomial distribution
#' 
#' @param xs A integer vector containing the list of observed counts. 
#' @param sizes A integer vector containg the list of total counts. Must be the same length with xs or a constant
#' @param ps A numeric vector containing the binomial probability for each observations. Must be the same length with ps or a constant
#' @param pos_only Ignore zeros in the distribution
#' @param var_adj Apply variance adjustment to improve power
#' @param approx_under Perform approximation in variance adjustment for Pr(X=x) smaller than the value
#' @return A vector of z-scores corresponding to expected overdispersion z-scores from SQuAT
#'    * zs : vector of z-scores corresponding to expected aggregated z-scores from SQuAT
#'    * sds : standard deviation of the expected z-scores (should be smaller than 1)
squat_multi_binom_bidir <- function(xs, sizes, ps, pos_only = TRUE, var_adj = TRUE, approx_under = 1e-4) {
    .Call(`_squat_squat_multi_binom_bidir`, xs, sizes, ps, pos_only, var_adj, approx_under)
}

#' Expectation of truncated normal from quantiles
#' Calculate expectation from truncated Normal
#' 
#' @param a lower quantile
#' @param b upper quantile
#' @param mu mean of the Normal
#' @param sd standard deviation of the Normal
#' @param lg compute log-scale
#' @param lower use lower tial quantiles
#' @return A single expected z-score for directional test
expt_truncated_normal_from_qt <- function(a, b, mu = 0, sd = 1, lg = 0L, lower = 1L) {
    .Call(`_squat_expt_truncated_normal_from_qt`, a, b, mu, sd, lg, lower)
}

#' Expectation of truncated normal from bidirectional quantiles
#' @description
#' Calculate expectation from truncated Normal - folded
#'
#' @param ql lower quantile
#' @param qu upper quantile
#' @param mu mean of the Normal
#' @param sd standard deviation of the Normal
#' @param lg compute log-scale
#' @param lower input quantiles are lower tail
#' @return A single expected z-score for overdispersion test
expt_truncated_bidir_normal_from_qt <- function(ql, qu, mu = 0, sd = 1, lg = 0L, lower = 1L) {
    .Call(`_squat_expt_truncated_bidir_normal_from_qt`, ql, qu, mu, sd, lg, lower)
}

#' Compute multiple bi-directional expected z-scores from quantiles 
#' @description
#' A function to generate bi-directional z scores based on input quantiles (from an arbitrary distribution)
#'
#' @param ql A vector of lower quantiles
#' @param qu A vector of upper quantiles
#' @param lg compute log-scale
#' @param lower input quantiles are lower tail
#' @return A vector including z-scores for the input quantile pairs
multi_bidir_zs_from_qt_n <- function(ql, qu, lg = 0L, lower = 1L) {
    .Call(`_squat_multi_bidir_zs_from_qt_n`, ql, qu, lg, lower)
}

#' Variance of bi-directional expected z-scores from quantiles
#' @name bidir_etn_var_from_qt
#' @description
#' A function to generate (approximated) variance for expectation based bi-directional z scores 
#' given an arbitrary distribution with the majority of mass captured by the input quantiles
#' 
#' @param qt A vector of quantiles
#' @param lg compute log-scale
#' @param lower input quantiles are lower tail
#' @return A vector including z-scores for the input quantile pairs
bidir_etn_var_from_qt <- function(qt, lg = 0L, lower = 1L) {
    .Call(`_squat_bidir_etn_var_from_qt`, qt, lg, lower)
}

#' Binomial bi-directional test 
#' @name binom_multi_bidir_n
#' 
#' @param xs A vector of non-negative counts representing observed data
#' @param sizes A vector of positive values representing total counts
#' @param ps A non-negative vector of probabilities
#' @param pos_only Ignore zero observations
#' @param var_adj Adjust variance to improved power
#' @param approx_under Use approximate variance calculation when Pr(X)<value
#' @return A list including z-scores and their variance
binom_multi_bidir_n <- function(xs, sizes, ps, pos_only = TRUE, var_adj = TRUE, approx_under = 1e-4) {
    .Call(`_squat_binom_multi_bidir_n`, xs, sizes, ps, pos_only, var_adj, approx_under)
}

#' Beta-binomial bi-directional test 
#' @name betabinom_multi_bidir_n
#' 
#' @param xs A vector of non-negative counts representing observed data
#' @param sizes A vector of positive values representing total counts
#' @param alphas A non-negative vector of parameters of the beta distribution
#' @param betas A non-negative vector of parameters of the beta distribution
#' @param pos_only Ignore zero observations
#' @param var_adj Adjust variance to improved power
#' @param approx_under Use approximate variance calculation when Pr(X)<value
#' @return A list including z-scores and their variance
betabinom_multi_bidir_n <- function(xs, sizes, alphas, betas, pos_only = TRUE, var_adj = TRUE, approx_under = 1e-4) {
    .Call(`_squat_betabinom_multi_bidir_n`, xs, sizes, alphas, betas, pos_only, var_adj, approx_under)
}

#' @title expt_truncated_gamma_from_qt
#' @description
#' Calculate expectation from truncated Gamma
#'
#' @param a lower quantile
#' @param b upper quantile
#' @param alpha shape parameter of Gamma
#' @param beta rate parameter of Gamma
#' @param lg compute log-scale
#' @param lower use lower tial quantiles
#' @return A single expected z-score for directional test
expt_truncated_gamma_from_qt <- function(a, b, alpha, beta, lg = 0L, lower = 1L) {
    .Call(`_squat_expt_truncated_gamma_from_qt`, a, b, alpha, beta, lg, lower)
}

#' @title expt_truncated_bidir_gamma_from_qt
#' @description
#' Calculate expectation from truncated Gamma - folded
#'
#' @param ql lower quantile
#' @param qu upper quantile
#' @param alpha shape parameter of Gamma
#' @param beta rate parameter of Gamma
#' @param lg compute log-scale
#' @param lower input quantiles are lower tail
#' @return A single expected z-score for overdispersion test
expt_truncated_bidir_gamma_from_qt <- function(ql, qu, alpha, beta, lg = 0L, lower = 1L) {
    .Call(`_squat_expt_truncated_bidir_gamma_from_qt`, ql, qu, alpha, beta, lg, lower)
}

#' @title squat_single_binom_unidir_g
#' @description
#' Function to calculate unidirectional z-score for single binomial distribution using Gamma approximation
#'
#' @param x            observed count
#' @param n            total number of trials
#' @param p            0-1 ranged binomial probability
#' @param alpha        shape parameter of the Gamma distribution
#' @param beta         rate parameter of the Gamma distribution
#' @param var_adj      perform variance adjustment if TRUE
#' @param approx_under threshold of binomial density to perform approximation during variance adjustment
#' @param lower        use lower tial quantiles
#' @return A z-score and its standard deviation
squat_single_binom_unidir_g <- function(x, n, p, alpha, beta, var_adj = TRUE, approx_under = 1e-4, lower = TRUE) {
    .Call(`_squat_squat_single_binom_unidir_g`, x, n, p, alpha, beta, var_adj, approx_under, lower)
}

#' @title squat_multi_binom_dir_g
#' @description
#' A function to generate two sample directional z scores based on exact quantiles from binomial distribution
#'
#' @param xs A integer vector containing the list of observed counts.
#' @param sizes A integer vector containg the list of total counts. Must be the same length with xs or a constant
#' @param ps A numeric vector containing the binomial probability for each observations. Must be the same length with ps or a constant
#' @param ys A binary vector indicating two groups.
#' @param var_adj Apply variance adjustment to improve power
#' @param approx_under Perform approximation in variance adjustment for Pr(X=x) smaller than the value
#' @return A list including z-scores and its two moments
squat_multi_binom_dir_g <- function(xs, sizes, ps, ys, var_adj = TRUE, approx_under = 1e-4) {
    .Call(`_squat_squat_multi_binom_dir_g`, xs, sizes, ps, ys, var_adj, approx_under)
}

